## 目的
<!-- 目的(〜を知りたい/〜を実装したい) -->
輪読会で理解を深める
## 成果
<!-- 成果(できたこと/できなかったこと) -->
- [x] 定数の際代入、変更
- [x] インスタンス変数とクラスインスタンス変数
- [x] @@
- [x] グローバル定数

#### 所要時間
- 120m
  - 60m(輪読会)
  - 60m(復習)
#### 使用資料
<!-- 使用資料(教材/書籍/ワークシート/Youtube) -->
- 🍒本7.8-7.9
## 詳細
<!-- 詳細(キーワード/プロセス//具体例を挙げる/今回の課題解決を今後に繋げられる形で記録) -->
- 定数はメソッド内では定義できないため、クラス構文の直下かトップレベルで定義
- ```クラス名::定数名```で呼び出せる
- 配列を定数で定義したときは、配列自体も、要素もそれぞれ定数として定義できる
  ```ruby
  class Drink
    COFFEE = [
      LATTE = 500,
      SOY = 600,
      DE_CAFFEE = 400
  ]
  end
  Drink::COFFEE #=> [500, 600, 400]
  Drink::LATTE #=> 500
  Drink::SOY #=> 600
  Drink::DE_CAFFEE #=> 400
  ```
- Rubyでは定数は他言語のように変更は可能だが、基本的に変更しない暗黙の圧がある
- 再代入や変更は可能
- 再代入は、警告は出るが.freezeしない限り変更される
- 定数の変更（upcaseやdeleteやpushメソッドなど）も可能だが破壊的変更が必要
  - 要素に対してupcaseメソッドを使う
  ```ruby
  class Drink
    COFFEE = ['latte', 'soy', 'de_caffee']
  end
  Drink::COFFEE[0].upcase! #=> "LATTE"
  Drink::COFFEE #=> ["LATTE", "soy", "de_caffee"]
  Drink::COFFEE[0].upcase #=> "LATTE"
  Drink::COFFEE #=> ["latte", "soy", "de_caffee"]
  ```
  - 破壊的なメソッドにしなければ配列の要素(Drink::COFFEEで出力)は変更されない
  - ```COFFEE = ['latte', 'soy', 'de_caffee'].freeze``` このようにしても、変更できないのは定数(COFFEE)への再代入だけで、要素は変更できる
  - 破壊的なメソッドを使用しても各要素を変更できないようにするためには
    ```ruby
    class Drink
      COFFEE = ['latte'.freeze, 'soy'.freeze, 'de_caffee'.freeze]
    end
    Drink::COFFEE[0].upcase! #`upcase!': can't modify frozen String: "latte" (FrozenError)
    Drink::COFFEE
    ```
    - これでフローズンエラーになる
    - 各要素１つづつに.freezeをつけずともmapを使えば良い
      ```ruby
      COFFEE = ['latte'.freeze, 'soy'.freeze, 'de_caffee'.freeze]
      COFFEE = ['latte', 'soy', 'de_caffee'].map(&:freeze)
      ```
- インスタンス変数は、同じ変数名だと継承してスーパークラスとサブクラスがあっても再代入されたら上書きされるので"同一"の変数が参照される
- クラスインスタンス変数は、同じ変数名でも継承していればサブクラスでオーバーライドされ"異なる変数"として参照される
  - このため、継承されている場合は特に変数に入っている値には注意が必要
- @@はインスタンス変数でも上書き可能
- $をつけたグローバル変数ならさらに、クラスの内部外部を問わずプログラムのどこからでも代入、参照ができる

## 考察
<!-- 考察(今後の展望/) -->
- 変数に再代入や変更はしたことがなかったが、警告はできても更新できたり、メソッドでの要素の変更も破壊的メソッドなら可能
- インスタンス変数とクラスインスタンス変数は見た目は"@変数名"なのに、値が異なる場合があるのは注意必要だし読みにくくなるから変数名に配慮があった方がいいのかな？
- @@したらインスタンス変数とか関係なく上書き可能になる...ジャイアンかよ
- と思ったら$変数名でクラスの内部外部を問わずプログラムどこからでも代入、参照できる...神か？
- あまり使わないといえど、影響力は大きそうなので使う時が来たらまた戻ってこよう